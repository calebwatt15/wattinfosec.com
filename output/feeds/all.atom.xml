<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>WattInfoSec</title><link href="https://wattinfosec.com/" rel="alternate"></link><link href="https://wattinfosec.com/feeds/all.atom.xml" rel="self"></link><id>https://wattinfosec.com/</id><updated>2016-02-21T00:00:00-06:00</updated><entry><title>Bypass Same Origin Policy on IE11 with a Null Origin</title><link href="https://wattinfosec.com/bypass-same-origin-policy-ie11-null-origin.html" rel="alternate"></link><updated>2016-02-21T00:00:00-06:00</updated><author><name>Caleb</name></author><id>tag:wattinfosec.com,2016-02-21:bypass-same-origin-policy-ie11-null-origin.html</id><summary type="html">&lt;h2&gt;The Background&lt;/h2&gt;
&lt;p&gt;Most browsers implement a Same-Origin policy (SOP). This means that resources from one origin can no be shared with a different origin (aka url, or domain). All major browsers do this. Chrome, Firefox, Edge, IE, Safari, etc. They all also have a way to bypass this restriction, a Cross-Origin Resource Sharing request (CORS). Basically, one website sends it's origin (domain) to another, and asks if it has permission to send requests cross-origin. This is done using an OPTIONS request. If the response has adequate headers for that domain, the browser will allow that domain to send near about any request to the other domain. &lt;/p&gt;
&lt;h2&gt;The Fun Part&lt;/h2&gt;
&lt;p&gt;I have found an issue with the above scenario while using IE11 (all versions from at least 11.0.9600.17801 through the current version, 11.0.9600.18059.) If a website has a NULL origin, IE11 does not first send the CORS Preflight OPTIONS request. It will instead just send the Cross Origin request (assuming the user has pressed "allow blocked content")&lt;/p&gt;
&lt;p&gt;&lt;img alt="IE11 asks the user to &amp;quot;Allow Blocked Content&amp;quot;" src="/images/bypass-same-origin-policy-ie11-null-origin01-Allow-Blocked-Content.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="IE11 Sends the DELETE request using Application/JSON without an OPTIONS pre-flight" src="/images/bypass-same-origin-policy-ie11-null-origin01-no-OPTIONS.png" /&gt;&lt;/p&gt;
&lt;p&gt;In a given scenario, a website wants to send a request with &lt;code&gt;content-type: application/json.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="A &amp;quot;dangerous&amp;quot; request, it is HTTP method DELETE, and uses a content-type of application/json" src="/images/bypass-same-origin-policy-ie11-null-origin01-Dangerous-Request.png" /&gt;&lt;/p&gt;
&lt;p&gt;In Chrome, the first site will first ask permission (as Chrome enforces), by sending an OPTIONS request. The receiving site denies permissions, and Chrome will not send the Cross-Origin request. The same thing happens in IE11, unless the site has a NULL origin. In Chrome, a NULL origin site still has to send a preflight request and obtain permission. In IE, if the Origin is NULL, IE will disregard the CORS policies, and send the full request regardless. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Chrome sends the required Pre-Flight OPTIONS request, unlike the IE request shown just below that that sent the DELETE right away." src="/images/bypass-same-origin-policy-ie11-null-origin01-Pre-Flight-Sent.png" /&gt;&lt;/p&gt;
&lt;p&gt;According to W3C, &lt;a href="https://www.w3.org/TR/2014/REC-cors-20140116/#resource-preflight-requests" title="CORS"&gt;Cross-Origin Resource Sharing recommendation&lt;/a&gt;, IF the Origin header is set, the Pre-Flight must be sent for these requests, however when the Origin is null, IE11 does not set the header at all. Per the recommendation: &lt;code&gt;If the Origin header is not present terminate this set of steps. The request is outside the scope of this specification.&lt;/code&gt;
So IE is not outside of the specification, in that the header is not being set (although the Origin is null, no Origin header is set.) That being said, why does IE not set the Origin header if it is NULL? Other browsers do (Read, Chrome), and therefore they fall within the spec.&lt;/p&gt;
&lt;p&gt;Now the question, how do we get a NULL origin? This is not really simple, in fact if an attacker wanted to abuse this flaw, they would have to get you to execute HTML from your local disk. If IE opens a web page from a local file, that "origin" is set to NULL. In this case, any Cross Origin requests would be sent without asking the other site for permission.&lt;/p&gt;
&lt;h2&gt;Thoughts&lt;/h2&gt;
&lt;p&gt;Now this attack vector is pretty small, and basically falls under the "Don't run anything on your machine that you do not trust" adage.
I have reported this to Microsoft, and given the small attack vector, they do not feel it is an issue. Given that if an attacker can convince you to run something on your system, they will more likely have you run malicious code, rather than HTML to perform an XSS or CSRF attack. &lt;/p&gt;
&lt;p&gt;Although I personally agree the attack vector is very small, if any flaw were found in the future to allow you to set your origin to NULL, this could be abused (if you could set your origin in general, CORS would be bypassed anyway). &lt;/p&gt;
&lt;p&gt;If you know of any way to set your origin to NULL in IE, please let me know. I would love to test this further.&lt;/p&gt;
&lt;h2&gt;Versions Tested&lt;/h2&gt;
&lt;p&gt;Internet Explorer 11 Versions:
&lt;em&gt;   11.0.9600.17416, 
&lt;/em&gt;   11.0.9600.17801, 
&lt;em&gt;   11.0.9600.18059, 
&lt;/em&gt;   11.0.10240.16590&lt;/p&gt;</summary><category term="WebApp Security"></category><category term="Same Origin Policy"></category><category term="Bypass"></category><category term="IE11"></category></entry><entry><title>Authorization Checks Should Use Different Passwords</title><link href="https://wattinfosec.com/authorization-checks-should-use-different-passwords.html" rel="alternate"></link><updated>2015-12-13T00:00:00-06:00</updated><author><name>Caleb</name></author><id>tag:wattinfosec.com,2015-12-13:authorization-checks-should-use-different-passwords.html</id><summary type="html">&lt;h2&gt;Insufficient Authorization&lt;/h2&gt;
&lt;p&gt;In web apps, every once in a while a user can change another user's account details by intercepting a request to change their own details, and modify some parameter in the request. This is often accomplished by modifying either an ID number, a username, or some other ID. In many cases, this means that an attacker may be able to create an account, then alter another account's password by trying to change their own, capture the request, and modify a username that is otherwise marked uneditable on the front end. &lt;/p&gt;
&lt;h2&gt;In Real Life&lt;/h2&gt;
&lt;p&gt;In a recent assessment, I ran accross this sort of problem. My two users were setup as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Breakdown of user information and permissions" src="/images/authCheckPasswordsDifferent01.png" /&gt;
The web application in question used an email address as the login username. This could not be changed once it was set. Even administrators were forbidden from editing any users' email addresses. In this case, the Account Details page has the "Email" field marked "Disabled", so that it could not be edited. If a user captured the request in a proxy, they could then edit the Email.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A user can email any field when capturing the request" src="/images/authCheckPasswordsDifferent03.png" /&gt;&lt;/p&gt;
&lt;p&gt;This lead to an interesting find. As a standard user, named "standard@test.com" I set my email to the admin user, named "admin@test.com". This let me change my email to the admin's login. &lt;/p&gt;
&lt;p&gt;&lt;img alt="StandardUser changes their email to admin@test.com" src="/images/authCheckPasswordsDifferent04.png" /&gt;&lt;/p&gt;
&lt;p&gt;Sadly, when I tried to login with "admin@test.com" and standard's password, it failed. However, if I tried to authenticate using "admin@test.com" and the normal admin password, it worked. &lt;/p&gt;
&lt;p&gt;Given this I assumed that the edit did not work since, admin@test.com was already a user, however I was wrong. If the admin email was input, with the admin password, then the application would authenticate the user, but it had the name and permissions of the standard user. This, in effect, forced the admin to have lower permissions, denying that admin the ability to perform admin duties. The admin had been forced into the standard user permissions, with the first and last name of the standard user.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Standard user's email and password were overwritten by the admin email and password, without any knowledge of the admin password" src="/images/authCheckPasswordsDifferent02.png" /&gt;
I may not have realized this as quickly, had I used the same password for both users. I would have assumed that the lower user took over the Admin account, as it would have been the lower user's password, name, and permissions. As is, this specific application allowed me to give another user my account, but it still had the proper username and password that they originally set. This would have been much harder, if even possible to notice without a different password for each user.&lt;/p&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Set all test accounts to different passwords, as during tests you will be more easily able to determine if a forced account change changed a user, or took over another account.&lt;/p&gt;</summary><category term="WebApp Security"></category></entry><entry><title>Vulnerability Reporting Database</title><link href="https://wattinfosec.com/vulnerability-reporting-database.html" rel="alternate"></link><updated>2015-10-30T16:25:00-05:00</updated><author><name>Caleb</name></author><id>tag:wattinfosec.com,2015-10-30:vulnerability-reporting-database.html</id><summary type="html">&lt;h2&gt;VRDB&lt;/h2&gt;
&lt;p&gt;I felt that there was lack of a decent open-sourced vulnerability database for writing vulnerability reports. CWE is kind of close, but does not have enough detail for specifics. This project is designed to fill that gap, and allow smaller shops to have a template for vulnerability reporting, without the resources of larger shops.&lt;/p&gt;
&lt;p&gt;It seems that nearly every vulnerability assessment shop has their own proprietary vulnerability reporting database. HP has one, IOActive has one, Whitehat has one. They all specialize and write custom vulnerability descriptions based on their expertise. This is all well and good. It makes their report writing immensely easier, and from what I have seen, they all have pretty good reports.&lt;/p&gt;
&lt;h2&gt;Purpose&lt;/h2&gt;
&lt;p&gt;I figured report writing is something rarely covered in new Tester education, and there are very few Vuln databases that do not focus on particular vulnerabilities. &lt;a href="http://osvdb.org/" title="OSVDB"&gt;OSVDB&lt;/a&gt; has thousands of particular vulnerabilities, and &lt;a href="https://web.nvd.nist.gov/view/vuln/search" title="NVD CVE"&gt;NVD CVE&lt;/a&gt; likewise has many known specific vulnerabilities, but if a vulnerability assessor is performing a test and finds a buffer overflow in a client-built application, that specific vulnerability is likely not in OSVDB or does not have a CVE. As such, the tester would benefit from having a default description and solution for that finding. The &lt;a href="https://cwe.mitre.org/" title="CWE"&gt;CWE&lt;/a&gt; is a very similar project to this, but I find it a little too sterile for use in reports. That said, if a client were to ask for additional resources on a vulnerability, CWE is spot on. As far as reading a vulnerability report goes, I would rather keep it slightly more simplified than that.&lt;/p&gt;
&lt;p&gt;As such, I have started writing the Vulnerability Reporting Database, or 
&lt;a href="https://github.com/calebwatt15/vrdb" title="vrdb"&gt;vrdb&lt;/a&gt;. 
It is (at this time) written in JSON, should be easily portable across many languages (many have a JSON parser) At this time, the database is small (there are only a handful of vulnerabilities in it that I have inserted during testing.) Most of them are Web Application vulnerabilities, using mostly descriptions and solutions from OWASP. I do plan on adding many more types of vulnerabilities, such as thick client, network, SAP, etc.&lt;/p&gt;
&lt;p&gt;In addition to the database, I have written a simple &lt;a href="https://github.com/calebwatt15/vrdbTool" title="vrdbTool"&gt;python script&lt;/a&gt; to write the JSON so I do not misformat it, that can also be found on GitHub. It is pretty hacky at this point, and is a project unto itself. Since the code in it is not very good, it should remain seperate  from the vrdb proper.&lt;/p&gt;</summary><category term="vrdb"></category><category term="project"></category></entry><entry><title>Attacking JSON only sites with CSRF</title><link href="https://wattinfosec.com/attacking-json-only-sites-with-csrf.html" rel="alternate"></link><updated>2015-09-23T13:13:00-05:00</updated><author><name>Caleb</name></author><id>tag:wattinfosec.com,2015-09-23:attacking-json-only-sites-with-csrf.html</id><summary type="html">&lt;h2&gt;The Background&lt;/h2&gt;
&lt;p&gt;The web has been built around the idea of a &lt;a href="https://www.w3.org/Security/wiki/Same_Origin_Policy" title="W3 - Same Origin Policy"&gt;same origin policy&lt;/a&gt;, and to get around that, &lt;a href="http://www.w3.org/TR/cors/" title="W3 - Cross-Origin Resource Sharing"&gt;CORS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The jist of this is that "odd" requests can not be sent to one domain from another. CORS allows web sites to ignore this, or allow certain domains to send "odd" requests. "Odd" here means anything that is not POST or GET. It also blocks many content types, such as application/xml or application/json. Many API based sites use PUT or DELETE calls in order to make requests. This makes them practically non-CSRF'able. Many sites also use all JSON requests, which should in-theory act the same way. Since an attacker can not force another domain to send application/json to a seperate domain.&lt;/p&gt;
&lt;h2&gt;The Fun Part&lt;/h2&gt;
&lt;p&gt;In my experience, many JSON parsers do not quite conform to the JSON RFC. According to the spec, JSON has a content type as follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content-type: application/json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As such, an attacker can not make their own personal domain send an XHR request with this content type, without the browser flagging it, and sending a CORS preflight reqeust to ask for permission from the other domain. The problem lies in that many JSON parsers do not actually check the Request headers. They are not actually confirming that this was a "JSON" request, so much as it looks like a JSON request. In many cases, an attacker can create an XHR request on their domain to send a body with a JSON formatted text, but includes a content-type header set to text/plain. Because the content type is not "odd", the browser will not flag the request, and will send this XHR request without first sending the CORS preflight request. &lt;/p&gt;
&lt;p&gt;I have tested this in PHP using the default json_decode. It works fine, without additional code, json_decode() does not check the content-type header. As such, any site written in PHP, using all JSON requests, is probably still vulnerable to CSRF attacks. &lt;/p&gt;
&lt;h2&gt;Thoughts&lt;/h2&gt;
&lt;p&gt;Basically OWASP recommends using randomized nonces (a random token) in the body of every request. This token should be long and have good entropy. It should also be a different token for every reqeust, for every session. Further reading can be found at &lt;a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" title="OWASP - CSRF"&gt;OWASP - CSRF&lt;/a&gt;. It is not sufficient to depend on Same Origin policy. Even with other HTTP Verbs, such as PUT or DELETE. CORS and SOP have been bypassed in the past, and will be again.&lt;/p&gt;
&lt;p&gt;As for attackers, before you write off a JSON only site as non-CSRF'able, make sure to try changing up the content-type headers. You may be able to attack this nonetheless.&lt;/p&gt;</summary><category term="WebApp Security"></category><category term="CSRF"></category><category term="Red Team"></category></entry></feed>